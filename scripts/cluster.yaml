issues:
  - title: 用途によるノードプールの分割
    body: |
      本格的なKubernetesクラスターでは、異なるワークロードを1つのクラスターで運用することが一般的です。その際、ワークロードごとの影響を最小限に抑えるため、用途別にノードを分割することが推奨されます。これにより、リソースの効率的な利用とセキュリティの向上が図れます。

      # ノード分割の必要性
      - アプリケーションとシステムコンポーネントの混在によるリソース競合
      - 異なるワークロードタイプに対する最適化不足（CPU集約的 vs メモリ集約的）
      - セキュリティ要件の違い（機密データを扱うアプリケーション vs 一般的なワークロード）
      - コンピューティングタイプの違い（Spot vs On-Demand、GPUの有無）
      
      # 解決策
      - Kubernetesレベルでの配置制御: PodのAffinity設定などでワークロードごと稼働するノードを制御。複数のPodに対する設定が必要で、運用が複雑になる。
      - インフラレベルでのノード分離: ノードプールを用途別に分割し、異なるノードグループでワークロードを管理。これにより、リソースの効率的な利用とセキュリティの向上が図れる。
      
      本プラクティスでは**インフラレベルでのノード分離**を採用します。インフラレベルでの完全分離、用途別最適化、運用のシンプルさ、セキュリティ境界の明確化が可能なためです。

      # EKS AutoModeでのノードプール分割
      - `nodeClass`リソースでノード設定のテンプレート化
      - `nodePool`リソースでノードのスペック範囲やノード終了の挙動を定義
      - `nodeSelector`、`tolerations`、`affinity`でPodの配置先を指定
      
      ## 一般的なノード分割パターン
      
      ### 1. システムコンポーネント用ノードプール
      - kube-system、aws-load-balancer-controller、cluster-autoscaler等
      - システム専用のtaintを設定
      
      ### 2. アプリケーション用ノードプール
      - ユーザーアプリケーション
      - 一般的なワークロード用の設定

      ### 3. 特定用途ノードプール（オプション）
      - GPU必要なML/AI ワークロード
      - 高メモリ要求のデータベース
      - セキュリティ要件の高いアプリケーション

      # EKS AutoMode組み込みのNodePoolについて

      EKS AutoModeでは`system`と`general-purpose`の2つの組み込みノードプールがあり、任意に有効/無効できます。いずれかのノードプールを有効にすると`default`というノードクラスが作成されノードプールで使用されます。すぐに利用出来て便利な反面、ノードプールの設定変更ができません。任意のノード設定やマシンタイプを指定したい場合、カスタムのノードクラスおよびノードプールを作成する必要があります。

      # プラクティス
      
      - システムコンポーネント用のnodePoolを作成する
        - 組み込みノードプールの`system`を無効
        - カスタムノードクラス`system`を作成
          - 設定は`default`と同じでいい
        - カスタムノードプール`system`を作成
          - 基本的には`general-purpose`と同じでいい
          - ノードクラスは`system`を指定
          - taintsで`Key:system`、`Effect:NoSchedule`を設定
      - `system`にPodをスケジュールする
        - `amazon-cloudwatch-observability-controller-manager`や`snapshot-controller`などのPodを`system`で動かす
          - EKSアドオンでデプロイしたものはアドオンの設定を変更する
  - title: StorageClassによる動的ボリューム作成
    body: |
      Kubernetesでステートフルなアプリケーションを動かす際、データの永続化が必要になります。EKS AutoModeでは、StorageClassを使用してEBSボリュームを動的に作成し、アプリケーションに自動的にアタッチできます。これにより、事前にボリュームを作成する必要がなく、必要に応じて自動的にストレージが提供されます。

      # Dynamic Volume Provisioningの必要性
      - ステートフルアプリケーション（データベース、ファイルストレージ等）でのデータ永続化
      - 手動でのボリューム作成・管理の運用負荷軽減
      - アプリケーションのスケーリングに合わせた自動的なストレージ拡張
      - 暗号化やボリュームタイプなどの統一的なストレージポリシー適用

      # 解決策
      - Static Provisioning: 事前にPersistentVolumeを手動作成し、PersistentVolumeClaimでバインド
      - Dynamic Provisioning: StorageClassを定義し、PersistentVolumeClaimの作成時に自動的にボリュームを作成

      本プラクティスでは**Dynamic Provisioning**を採用します。運用負荷の軽減、一貫したボリューム設定の適用、オンデマンドでのストレージ提供が可能なためです。

      # EKS AutoModeのDynamic Volume Provisioning
      - EKS AutoModeでは`ebs.csi.eks.amazonaws.com`プロビジョナーを使用
      - StorageClassでEBSボリュームの設定（タイプ、暗号化、IOPS等）を定義
      - PersistentVolumeClaimが作成されると自動的にEBSボリュームが作成される
      - `volumeBindingMode: WaitForFirstConsumer`でPodが起動するまでボリューム作成を遅延

      ## StorageClassの基本設定
      ```yaml
      apiVersion: storage.k8s.io/v1
      kind: StorageClass
      metadata:
        name: auto-ebs-sc
        annotations:
          storageclass.kubernetes.io/is-default-class: "true"
      provisioner: ebs.csi.eks.amazonaws.com
      volumeBindingMode: WaitForFirstConsumer
      parameters:
        type: gp3
        encrypted: "true"
      ```

      [参考](https://docs.aws.amazon.com/ja_jp/eks/latest/userguide/create-storage-class.html)

      ## ストレージの暗号化
      - `encrypted: "true"`でEBSボリューム暗号化を有効化
      - デフォルトでは`aws/ebs`マネージドキーを使用
      - `kmsKeyId`パラメータでカスタマーマネージドキーも指定可能

      # プラクティス

      StorageClassを作成し、サンプルステートフルアプリケーションで動的ボリューム作成を確認する。

      - StorageClassを作成する
        - `codes/eks/k8s`ディレクトリにStorageClassマニフェストを作成
        - プロビジョナーは`ebs.csi.eks.amazonaws.com`を指定
        - gp3ボリュームタイプで暗号化を有効化
        - デフォルトStorageClassとして設定
      - サンプルアプリケーションをデプロイする
        - `nginx`等のイメージを使ったDeploymentを作成
        - PersistentVolumeClaimでストレージを要求
        - Podでボリュームをマウントしてデータ永続化を確認
      - 動作確認
        - PVCが作成され、自動的にEBSボリュームが作成されることを確認
        - Pod削除・再作成後もデータが永続化されていることを確認
        - AWS ConsoleでEBSボリュームが暗号化されていることを確認

  - title: Ingressによる外部公開
    body: |
      K8sのワークロードを外部公開する方法としてIngressがあります。Ingressは動作を制御する Ingress Controller を介し、LBなどの外部リソースと連携してトラフィックをルーティングします。EKS AutoModeではAWS Load Balancer Controllerのインストールが不要で、EKS AutoModeが自動的にALBを作成・設定します。

        # EKS AutoMode Ingressの概要
        - EKS AutoModeはルーティングタスクを自動化し、アプリサーバーをインターネットに公開
        - Ingressリソース作成時に自動的にALBが作成される
        - IngressClassとIngressClassParamsを使用してALB設定をカスタマイズ
        - 従来のAWS Load Balancer Controllerのインストールは不要

        ## 必要なリソース構成
        1. **IngressClassParams** - AWS固有の設定値（証明書、VPCサブネット等）を定義
        2. **IngressClass** - EKS AutoModeをコントローラーとして指定
        3. **Ingress** - HTTPパスとポートをクラスタワークロードに関連付け

        ## EKS AutoModeの利点
        - AWS Load Balancer Controllerの手動インストール・管理が不要
        - ALBの自動作成・設定によるオペレーション負荷軽減
        - Kubernetes標準のIngressリソースとAWS ELBサービスの統合
        - セキュリティ設定やネットワーク設定の自動化

        # プラクティス

        FrontendをServiceタイプLoadBalancerによる公開からIngressによる公開に変更する。

        - IngressClassParamsとIngressClassの作成
          - `codes/eks/k8s`ディレクトリにIngress関連のマニフェストを作成 [参考](https://docs.aws.amazon.com/ja_jp/eks/latest/userguide/auto-configure-alb.html)
            - IngressClassParams
            - IngressClass
        - Frontendリソースの作成
          - ServiceリソースのタイプをClusterIPに変更
          - Ingressリソースを定義してFrontendを外部公開
        - 動作確認
          - 上記リソースを全て作成後、Ingressリソースを確認しLBのDNS名を取得
          - DNS名でWebブラウザからアクセス可能か確認
            - Ingressが作成されてからALBが利用可能になるまで数分かかる場合がある
