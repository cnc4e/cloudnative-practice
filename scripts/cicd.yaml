issues:
  # - title: cert-managerをセットアップする
  #   body: |
  #     cert-manager をセットアップする**cert-manager**モジュールを作成する。  
  #     コードは`codes`ディレクトリ配下に`cert-manager`ディレクトリを作成し、そこにコードを配置する。  
  #     コードを作成し、リソースのデプロイが完了したらPRを出す。
      
  #     # cert-managerについて
  #     cert-manager は K8s のためのオープンソースの証明書管理ツールです。  
  #     K8s のリソースとして証明書を管理し、証明書の自動更新や発行を行うことができます。  
  #     K8s にインストールするオペレーターなどのカスタムコントローラーはAPIサーバーと通信します。  
  #     その際、通信の暗号化のためにTLS証明書が必要になります。  
  #     cert-manager はそのTLS証明書を自動で管理してくれるツールです。  
  #     多くのオペレーターは導入前提として cert-manager を必要とします。

  #     # 欲しいもの
  #     - cert-manager
  #       - helm を使いインストール
  #         - 以下オプションを values.yaml に定義してコードに残す
  #           - crd: true
  #           - prometheus: false
  #       - インストール方法は[ここ](https://cert-manager.io/docs/installation/helm/)を参考にする

  #     # その他
  #     helmの使い方は次を参考にすること。
  #     - [Helmの使い方](https://helm.sh/ja/docs/intro/using_helm/)
  #     - [Helmの使い方を3分で理解する](https://qiita.com/MahoTakara/items/3c509235cc18bd407f07)
  - title: GitHub Actions Runnerをセットアップする
    body: |
      CIを実行するためのGitHub Actions Runnerをセットアップする。  
      README.mdは`codes`ディレクトリ配下に`actions`ディレクトリを作成し、そこにREDME.mdを配置する。  
      README.mdを作成し、リソースのデプロイが完了したらPRを出す。

      # 構成説明
      GitHub Actions は GitHub の PullRequest などをトリガーにワークフローを実行する。  
      ワークフローには複数のジョブを含めることができ、各ジョブはGitHub Actions Runner（ランナー）で実行される。  
      ランナーはGitHubのサーバー上で実行されるホスト型ランナーと、ユーザーが管理するセルフホスト型ランナーの2種類がある。  
      今回はセルフホスト型のランナーをK8sに作成する。  
      ランナーを作る方法はいくつかあるが、ここでは [GitHub Actions Runner Controller](https://github.com/actions/actions-runner-controller)(ARC) を使用する。  
      ARCはK8sにインストールするオペレーター（特定のアプリケーションやサービスの運用を自動化する仕組み）の一つ。  
      ARCを使用することで、K8sのPodとしてGitHub Actions Runnerを実行できるようになる。

      # 欲しいもの
      - ARC
        - helmを使いインストール
          - インストール方法は[Actions Runner Controller のクイックスタート](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller)を参考にする
        - `helm install`のコマンド全文を`actions`ディレクトリ配下の`README.md`に書いて保存すること
      - RunnerScaleSet
        - helmを使いインストール
        - 自身の`cloudnative-practice`リポジトリを指定したランナーをデプロイする
        - 認証方法は`PAT`または`GitHub App`を使用する
          - `PAT`の方が設定は楽。ただしトークンは個人に紐づく
          - `GitHub App`の方は個人に紐づかないため実PJ向き
        - 認証情報を格納したSecretはマニフェストに**含めない**こと
          - Gitに認証情報を含めると漏洩する可能性があるため
        - `helm install`のコマンド全文を`actions`ディレクトリ配下の`README.md`に書いて保存すること

      # その他
      RunnerScaleSetデプロイ後、GitHubの自身の`cloudnative-practice`リポジトリで settings > Actuins > Runners を開きRunnerがオンラインになっていることを確認する。
  - title: GitHub Actions の動作確認をする
    body: |
      セットアップしたセルフホストランナーでワークフローが実行できることを確認する。
      動作確認用に手動トリガーで実行するワークフローを作成する。
      GitHub Actionsのワークフローは`.github/workflows/`ディレクトリに定義ファイルを配置する。

      # 前提

      - GitHub Actions Runnerのセットアップが完了していること

      # やること

      - 以下の内容の`test.yml`をリポジトリのルート直下``.github/workflows/``ディレクトリに作成する。`runs-on`に settings > Actuins > Runners で確認できるRunner名を指定
        ```yaml
        name: Self-hosted Runner Test

        on:
          workflow_dispatch:  # 手動トリガー

        jobs:
          test-runner:
            runs-on: arc-runner-set
            steps:
              - name: 確認用の echo 出力
                run: echo "🎉 Self-hosted Runner でワークフローが実行されました！"
        ```
      - 変更をコミットし、GitHubにプッシュする。PRは不要（PRを出してもいい）。
      - GitHubで Actions タブを開き、左のワークフロー一覧に`Self-hosted Runner Test`が表示されていることを確認
      - `Self-hosted Runner Test`を選択し`Run workflow`ボタンをクリックしてワークフローを実行
      - しばらくしてから画面をリロードするとワークフローが実行される。茶色は実行中、緑は成功、赤は失敗
      - 緑になったらワークフローを選択。実行されたジョブが表示される。`test-runner`ジョブを選択し、ジョブの詳細を表示
      - `確認用の echo 出力`のステップを選択し、`🎉 Self-hosted Runner でワークフローが実行されました！`と表示されていれば成功
  - title: Runner に Pod Identity でIAMロールをアタッチする
    body: |
      Runner が ECR にアクセスできるように、Pod Identity を使って IAM ロールをアタッチする。
      コードは`codes/actions`ディレクトリに配置する。
      コードを作成し、リソースのデプロイが完了したらPRを出す。

      # 前提

      - GitHub Actions Runnerのセットアップが完了していること

      # EKSのPodのIAMロールについて

      EKSのPodはデフォルトではノードのIAMロールを継承する。
      ノードのIAMに必要以上に権限を与えると、ノード上で動くPodに不必要な権限が与えられてしまう。
      そのため、Podごとに必要な権限を与えるIAMロールをアタッチすることが推奨される。

      EKSにはPodにIAMロールをアタッチする方法が2つあるが、EKSオートモードでは [Pod Identity](https://docs.aws.amazon.com/ja_jp/eks/latest/userguide/pod-identities.html)がデフォルト使えるため本プラクティスでは Pod Identity を使用する。

      # 欲しいもの

      - Runner Podに付与するIAMロール
        - 必要な権限は以下の通り
          - `ecr:GetAuthorizationToken`
          - `ecr:BatchCheckLayerAvailability`
          - `ecr:GetDownloadUrlForLayer`
          - `ecr:BatchGetImage`
          - `ecr:PutImage`
        - IAMロールは Pod Identity を使ってアタッチできるように信頼ポリシーを設定する
          - `Service:pods.eks.amazonaws.com`
          - `Action:["sts:AssumeRole","sts:TagSession"]`
      - Pod Identity の設定 [aws_eks_pod_identity_association](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/eks_pod_identity_association)
        - IAMロールはPod用に作成したロールを指定
        - Runner Pod の Namespace と ServiceAccount を指定。クイックスタート通りに作っている場合は以下の通り
          - ns:arc-runners
          - sa:arc-runner-set-gha-rs-no-permission
        - EKSクラスタ名はできればeksモジュールからoutputで取得すること

  - title: フロンエンドのコンテナをビルドしてECRにプッシュするワークフローを作成する
    body: |
      ほげ
  - title: バックエンドのコンテナをビルドしてECRにプッシュするワークフローを作成する
    body: |
      ほげ
  - title: Argo CD をセットアップする
    body: |
      ほげ
  - title: フロントエンドのデプロイをGitOpsで行う
    body: |
      ほげ
  - title: バックエンドのデプロイをGitOpsで行う
    body: |
      ほげ
