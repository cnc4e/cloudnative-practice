issues:
  - title: Checkovによるポリシーチェック
    body: |
      プロジェクト独自のルールや規約（命名規則、タグ付けルール、リージョン制約など）を自動的に検査し、遵守を確保することは重要です。ポリシーチェックツールを使用することで、これらのプロジェクト固有のルールとセキュリティベストプラクティスの両方を自動検査し、コードの品質とセキュリティを向上させることができます。

      # ポリシーチェックの必要性
      - プロジェクト固有のルール（命名規則、タグ付け、リージョン制約）の遵守確認が必要
      - 複数開発者による一貫した設定の維持とコードの統一性の確保
      - 手動によるルール確認は時間がかかり、見落としやヒューマンエラーが発生しやすい
      
      # 解決策
      - **Checkov**: YAMLベースの直感的なカスタムポリシー定義、TerraformとKubernetes両対応（本プラクティス採用）
      - **Trivy**: 高速実行、統合セキュリティスキャナー、カスタムポリシーはOPA/Regoが必要
      - **Terrascan**: OPA/Regoベース、柔軟だが学習コストが高い
      - **KICS**: 独自のクエリ言語、カスタムポリシー作成が複雑
      
      本プラクティスではYAMLでのカスタムポリシー定義が容易で、TerraformとKubernetesの両方に対して統一的なポリシー管理が可能なCheckovを採用します。

      # Checkovによるポリシーチェック
      - Checkovは1000以上のセキュリティ・コンプライアンスチェックを内蔵
      - Terraform、Kubernetes、Docker、CloudFormationなど多様な形式をサポート
      - カスタムポリシーの作成により組織固有のルールを適用可能
      - JSON、SARIF、JUnit形式での結果出力によりCI/CD統合が容易

      ## Checkovのインストールと基本的な使い方

      - [Quick Start - checkov](https://www.checkov.io/1.Welcome/Quick%20Start.html)

      ## 主要なチェック項目
      
      - [kubernetes resource scans - checkov](https://www.checkov.io/5.Policy%20Index/kubernetes.html)
      - [terraform resource scans - checkov](https://www.checkov.io/5.Policy%20Index/terraform.html)      

      ## カスタムポリシーの作成
      
      [Custom Policies Overview - checkov](https://www.checkov.io/3.Custom%20Policies/Custom%20Policies%20Overview.html)

      # プラクティス
      
      ## 基本的なCheckovスキャン
      - checkovをローカル端末にインストール
      - カスタムポリシーを定義し、プロジェクトのルールを自動検査
      - 今回はあえてチェックに`失敗`するようなポリシーを定義（作成したポリシーを別のissueで使います。）
        - codes/checkovディレクトリを作成
        - ディレクトリ内にカスタムポリシーのYAMLを作成
          - ポリシーのIDは`CUSTOM_AWS_PROVIDER_CHECK`にする
          - TerraformのAWSプロバイダーにdefault_regionが`us-west-1`である事を確認
      - 作成したポリシーを使いcheckovを実行しカスタムポリシーの確認結果が`FAILED`になることを確認
        - 対象は`codes/actions/terraform`ディレクトリなど任意
        - `--check "CUSTOM_*"`を付けるとカスタムポリシーのみチェックできる
  - title: CheckovによるポリシーチェックをCIに組み込む
    body: |
      CI/CDパイプラインにポリシーチェックを統合することで、開発者が変更をプッシュする度に自動的にセキュリティとコンプライアンスの検証を行い、問題のあるコードが本番環境にデプロイされることを防げます。

      # CI統合の必要性
      - 開発者の手動実行に依存すると、ポリシーチェックが忘れられる可能性がある
      - プルリクエスト時点での自動検証により、早期に問題を発見・修正できる
      - 継続的なセキュリティとコンプライアンスの維持が可能になる
      - チーム全体での一貫したポリシー適用の強制ができる
      
      # 解決策
      - **GitHub Actions**: 無料プラン利用可能、Checkovの公式アクションあり、設定が簡単（本プラクティス採用）
      - **GitLab CI**: GitLab利用時の選択肢、Dockerイメージでの実行
      - **Jenkins**: 自前構築が必要、柔軟性が高い
      - **CircleCI**: 有料プラン必要、高性能な実行環境
      
      本プラクティスではGitHub Actionsを使用し、プルリクエスト時に自動的にCheckovスキャンを実行する仕組みを構築します。

      # GitHub ActionsでのCheckov統合
      - Checkovには公式のGitHub Actionが提供されている
      - プルリクエスト作成時およびコードプッシュ時に自動実行
      - 結果をプルリクエストのコメントに表示可能
      - 失敗時のワークフロー停止により問題のあるマージを防止

      # プラクティス

      ## 前提

      - Checkovによるポリシーチェック のissueを完了していること

      ## CI統合のためのワークフロー作成
      - `.github/workflows/`ディレクトリに`checkov.yml`ワークフローファイルを作成
      - mainへのプルリクエストをトリガーとしてワークフローを実行
      - [checkov-action](https://github.com/bridgecrewio/checkov-action)を参考にcheckovを実行
        - Terraformディレクトリ（`codes/actions/terraform`等）をスキャン
        - フレームワークは`terraform`
        - カスタムポリシー（`codes/checkov/`）を使用
        - チェックは`CUSTOM_*`のみ

      ## ワークフローのテスト
      - 作業ブランチをリモートにプッシュしPRを作成
      - GitHub Actionsでチェックが自動で行われ**失敗**することを確認
      - `codes/checkov`配下のポリシーを修正しリモートに再プッシュ
      - GitHub Actionsでチェックが自動で行われ**成功**することを確認

      ## 更に発展的なプラクティス
      このプラクティスは余裕がなければやらなくてもいいです。

      - 対象ディレクトリをハードコードではなく変更のあったTerraformディレクトリにする

  - title: AtlantisによるPRベースのterraform plan/apply
    body: |
      Pull Requestベースでのインフラ管理により、レビュープロセスを通じてインフラストラクチャの変更を制御し、変更内容の可視化とガバナンスを強化できます。Atlantisを使用することで、GitOpsワークフローを実現し、Pull Request上で直接terraform planの結果を確認し、レビュー後にterraform applyを実行できます。

      # PRベースインフラ管理の必要性
      - Terraformの実行が個人のローカル環境に依存し、状態管理や権限管理が困難
      - インフラ変更のレビュープロセスが不十分で、予期しない変更が本番環境に反映されるリスク
      - 複数人でのインフラ管理において、実行履歴の追跡と変更の透明性が不足
      - ローカル環境での実行により、一貫性のない実行環境とコンフィグレーションの問題
      
      # 解決策
      - **Atlantis**: GitHubとの統合が優れており、PRコメントでの操作が直感的（本プラクティス採用）
      - **Terraform Cloud**: HashiCorpの公式サービス、リモート実行とstate管理が統合
      - **GitHub Actions**: 自前でワークフローを構築、カスタマイズ性が高い
      - **GitLab CI**: GitLab利用時の選択肢、統合開発環境として利用可能
      
      本プラクティスではGitHub Pull Requestとの親和性が高く、コメントベースでの直感的な操作が可能なAtlantisを採用します。

      # Atlantisによる GitOps ワークフロー
      - Pull Request作成時に自動的にterraform planを実行
      - plan結果をPRコメントに表示し、変更内容を事前に確認可能
      - レビュー承認後、コメントによりterraform applyを実行
      - 実行ログとstate管理を一元化し、トレーサビリティを確保

      ## Atlantisの主要機能
      - **自動plan実行**: PR作成/更新時の自動terraform plan実行
      - **PRコメント統合**: planとapplyをPRコメントから実行
      - **ポリシーチェック**: Conftest等によるOPAポリシー適用
      - **並列実行制御**: 同時実行の制限とロック機能

      # プラクティス

      ## Atlantisサーバーの構築
      - `codes/atlantis/`ディレクトリを作成し、AtlantisのEKSデプロイメント用マニフェストを作成
        - Deployment、Service、IngressまたはLoadBalancer設定
        - GitHub App認証情報の設定（Secret）
        - Atlantis設定ファイル（`atlantis.yaml`）の作成
      - EKSクラスターにAtlantisをデプロイ

      ## GitHub認証情報の設定
      - [Git Host Access Credentials | Atlantis](https://www.runatlantis.io/docs/access-credentials.html)
        - GitHubユーザーのPATまたはGitHub Appを使用（ARCで作成した認証情報を使いまわしてもいい）

      ## リポジトリ設定とワークフロー確認
      - リポジトリルートに`atlantis.yaml`設定ファイルを配置
        - Terraformディレクトリのpattern指定
        - plan/applyの実行コマンド設定
        - 事前・事後実行フックの設定（Checkovスキャン等）
      - テスト用のTerraform変更でPull Requestを作成
      - 自動plan実行とPRコメント表示の確認
      - レビュー後の手動apply実行とstate更新の確認

  - title: GitHub Actionsによる定期的なドリフトチェック
    body: |
      hoge
  - title: ブランチ戦略
    body: |
      hoge
  - title: モジュール化
    body: |
      hoge
  - title: クラスタのバージョンアップ
    body: |
      hoge
  - title: バックアップ/リカバリ
    body: |
      hoge
