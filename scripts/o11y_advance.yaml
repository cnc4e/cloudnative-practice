issues:
  - title: Container Insights のロググループを分割する
    body: |
      Container Insights が収集するログはデフォルトでは決まったロググループに集約されますが、ログの種類や用途に応じてロググループを分割することが推奨されます。

      # ロググループ分割の必要性
      - Container Insights はデフォルトで `/aws/containerinsights/<cluster-name>/application` という単一のロググループにPodログを出力する
      - 大規模なクラスターでは大量のログが生成され、単一のロググループでは管理が困難になる
      - ログの種類やリテンション期間を分けることで、コスト最適化が可能になる
      - Pod、サービス別にログを分離することで、特定のコンポーネントの監視とトラブルシューティングが効率化される
      
      # 解決策
      - CloudWatch Logs のロググループをあらかじめ作成する
      - FluentBit の設定をカスタマイズして、ログを複数のロググループに分割する
      
      本プラクティスでは、2つの解決策を組み合わせ Container Insights のログを複数のロググループに分割し、効率的な管理とコスト最適化を実現します。

      # Container Insights ロググループ分割の方法
      
      ## 1. 複数ロググループの作成
      - Terraform を使用して複数のロググループを作成する
      - 各ロググループに適切なリテンション期間を設定する
      - 必要に応じて KMS 暗号化を有効にする
      - タグを設定してコスト管理を効率化する
      
      ## 2. FluentBitの設定
      - 種類別に出力先のロググループを設定する

      # プラクティス
      
      - FrontendとBackendのログをそれぞれ専用のロググループに分割する
        - AWSリソースの準備
          - 以下名前のロググループを作成する
            - `/aws/containerinsights/<cluster-name>/backend`
            - `/aws/containerinsights/<cluster-name>/frontend`
          - 各ロググループにログの有効期限として`30日`を設定する
        - Container Insights(FluentBit)の設定
          - クラスタに作成済の ConfigMap:fluent-bit-config を編集する
            - ConfigMap内の`application-log.conf:`以下がアプリケーションログの設定箇所
              - 既存の`[OUTPUT]`を参考にfrontendとbackendの出力設定をする
                - `*frontend*`および`*backend*`に該当するログを指定
                - ログの出力先としてそれぞれ作成したロググループを指定
          - ConfigMapを修正したらFluentBitのDaemonSetをリスタート
        - 動作確認
          - frontend等にアクセスする
          - アクセスした時のログがCloudWatchLogsに出力されていることを確認

      # 更に発展的なプラクティス

      - ConfigMapの設定変更をEKSアドオンのオプション設定で行う

  - title: ログを構造化してメトリクス化
    body: |
      Nginxのアクセスログを構造化し、CloudWatch Logs Insightsでクエリしやすくし、さらにログベースのメトリクスを作成することで、アプリケーションの健全性を監視できます。

      # ログ構造化とメトリクス化の必要性
      - デフォルトのNginxアクセスログは非構造化されており、検索やフィルタリングが困難
      - ログから重要な情報（レスポンス時間、エラー率、リクエスト数など）を抽出するのに時間がかかる
      - アプリケーションの問題を早期に発見し、迅速に対応するためには構造化されたログとメトリクスが必要
      - ログベースのメトリクスにより、詳細なアラートやダッシュボードを作成できる
      
      # 解決策
      - アプリケーションのログをJSONで出力する
      - FluentBitのパーサーを使用してログを構造化する
      
      本プラクティスでは、FrontendのNginxログをNginxパーサーを使い構造化し、ログベースのメトリクス監視を実現します。

      # ログ構造化とメトリクス化の方法
      
      ## 1. FluentBitでのNginxログ処理
      - nginx パーサーを使用してアクセスログを解析 [Configuring parsers](https://docs.fluentbit.io/manual/data-pipeline/parsers/configuring-parser)
      - アプリケーションログの設定にNginxログをNginxパーサーを使い構造化するフィルターを追加

      ## 2. メトリクスフィルターの作成
      - ステータスコード（2xx、3xx、4xx、5xx）の数をカウントするメトリクスフィルターを設定

      # プラクティス
      
      - FrontendのNginxログを構造化し、メトリクス化する
        - FluentBitの設定修正
          - ConfigMap:fluent-bit-config の parsers.conf に nginx パーサーを追加
            - formatは`regrex`
            - Regexは` ^(?<remote>[^ ]*) (?<host>[^ ]*) (?<user>[^ ]*) \[(?<time>[^\]]*)\] "(?<method>\S+)(?: +(?<path>[^\"]*?)(?: +\S*)?)?" (?<code>[^ ]*) (?<size>[^ ]*)(?: "(?<referer>[^\"]*)" "(?<agent>[^\"]*)")?.*$`
          - ConfigMap:application-log.conf でfrontendに該当するログにnginxパーサーを適用
          - ConfigMapを修正してapplyしたらFluentBitのDaemonSetをリスタート
        - メトリクスフィルターの作成
          - 各ステータスコード（2xx、3xx、4xx、5xx）をカウントするメトリクス
            - パターンは`"{ $.code = \"2*\" }"`などを指定
            - メトリクスの名前空間は`Custom/HTTPStatus`など
            - メトリクス名は`FrontendHttp2xxCount`など
            - 検出したら値を`1`としてカウント
        - 動作確認
          - frontendにアクセスしてログを生成
          - CloudWatch Logs に送られたログが以下のように構造化されている
            ``` JSON
            {
                "remote": "169.254.7.127",
                "host": "-",
                "user": "-",
                "method": "GET",
                "path": "/",
                "code": "200",
                "size": "208",
                "referer": "-",
                "agent": "kube-probe/1.32+",
                "time": "2025-09-02T09:01:37.903131401Z",
                "stream": "stdout",
                "_p": "F",
                "kubernetes": {
                    "pod_name": "frontend-56dbfc78cd-zmcdr",
                    "namespace_name": "default",
                    "pod_id": "1e8384f6-0d30-4609-9973-bf58a867677d",
                    "host": "i-08878310cf8bb3b93",
                    "container_name": "nginx",
                    "docker_id": "70330fa3e583650902a57b680cc29cc62916c9f23379de0f042606926e2612cd",
                    "container_hash": "456247443832.dkr.ecr.ap-northeast-2.amazonaws.com/frontend@sha256:e074407327a1b1d4bd0020cbcae4a598982f11a68eb5b6d9c9ed772d9903d417",
                    "container_image": "456247443832.dkr.ecr.ap-northeast-2.amazonaws.com/frontend:202507181652"
                }
            }
            ```
          - CloudWatch Metrics にメトリクスが作成され、各ステータスコードのカウント数が可視化できること

  - title: Application Signalsを使ったJavaアプリケーションのメトリクス収集
    body: |
      Application Signalsを使ってJavaアプリケーションの詳細なメトリクス収集とトレーシングを行い、アプリケーションの可観測性を向上させます。

      # Application Signalsの必要性
      - Container InsightsはK8s観点のメトリクスは収集するが、Pod内のアプリケーションレベルの詳細なメトリクスは収集しない
      - 例えばJavaアプリケーションの場合、JMXメトリクスは収集されない
      - アプリケーションの動作をより深く理解し、パフォーマンスのボトルネックやエラーの原因を特定するためには、アプリケーションレベルのメトリクスが必要になる
      
      # 解決策
      - CloudWatch Application Signalsを有効化し、対応したアプリケーションのメトリクスを収集する
      - Prometheusでメトリクスを収集
      - OpenTelemetryを使ってメトリクスを収集
      
      本プラクティスでは、Application Signals を適用し、詳細なメトリクス収集を実現します。

      # Application Signalsの概要
      
      - Java等の対応したアプリケーションのメトリクスを収集できる [サポートされるテクノロジースタック](https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/monitoring/appinsights-what-is.html#appinsights-stack)
      - CloudWatch Observability EKS アドオンに組み込まれている
      - ワークロード(NamespaceまたはPod)で有効化するだけで利用可能
      - 収集されるメトリクス [Application Signals によって収集されるメトリクス](https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/monitoring/AppSignals-MetricsCollected.html#AppSignals-RuntimeMetrics)
      
      # プラクティス

      - アカウントでCloudWatch Application Signalsを有効化する
        - CloudWatch > Application Signals > サービス を選択。`ステップ 1. サービス検出の 1 回限りの設定`が完了していること
        - 上記完了していない場合は公式ドキュメントを参考に設定を行う [アカウントで Application Signals を有効にする](https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/monitoring/CloudWatch-Application-Signals-Enable.html)
      - Javaアプリケーションをデプロイし、Application SignalsでJMXメトリクスを収集する
        - 以下のJavaアプリケーションをデプロイする
          - Deployment
          - イメージ:`ryotamori/jmx-agent-example:v2`
          - podTemplateのannotationsに`instrumentation.opentelemetry.io/inject-java: "true"`を追加
      - 確認
        - CloudWatchメトリクスのカスタム名前空間に`ApplicationSignals`が追加され、JMX関連のメトリクスを確認する
